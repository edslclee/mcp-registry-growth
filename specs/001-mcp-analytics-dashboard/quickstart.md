# Quickstart: MCP Server Analytics Dashboard

**Purpose**: Step-by-step guide to set up, develop, and deploy the dashboard

## Prerequisites

- Node.js 18+ and npm/yarn/pnpm
- Git
- GitHub account (for Actions)
- Basic knowledge of Next.js and React

---

## 1. Project Initialization

### Create Next.js Project

```bash
npx create-next-app@latest mcp-registry-growth --typescript --tailwind --app --no-src-dir
cd mcp-registry-growth
```

**Configuration selections**:
- TypeScript: Yes
- ESLint: Yes
- Tailwind CSS: Yes
- App Router: Yes
- `src/` directory: No
- Import alias: Yes (@/*)

### Install ShadCN UI

```bash
npx shadcn-ui@latest init
```

**Configuration**:
- Style: Default
- Base color: Slate (good for dark theme)
- CSS variables: Yes

**Install required components**:
```bash
npx shadcn-ui@latest add button card select skeleton
```

### Install Charting Library

```bash
npm install recharts
npm install --save-dev @types/recharts
```

---

## 2. Configure Static Export

### Update `next.config.js`

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',  // Enable static export
  images: {
    unoptimized: true  // Required for static export
  }
};

module.exports = nextConfig;
```

### Update `.gitignore`

```
/out
/data/snapshots.csv
```

**Note**: `snapshots.csv` will be generated by GitHub Actions, so it's initially ignored. After first run, remove from .gitignore to commit updates.

---

## 3. Set Up Dark Theme

### Update `tailwind.config.ts`

```typescript
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}'
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#a855f7',  // Purple
          light: '#c084fc',
          dark: '#7e22ce'
        },
        accent: {
          blue: '#3b82f6',
          pink: '#ec4899'
        }
      }
    }
  },
  plugins: []
};

export default config;
```

### Update `app/globals.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 5%;       /* gray-950 */
    --foreground: 0 0% 95%;      /* gray-100 */
    --primary: 270 91% 65%;      /* purple-500 */
  }

  body {
    @apply bg-gray-950 text-gray-100 antialiased;
  }
}
```

---

## 4. Create Data Aggregation Script

### Create `scripts/aggregate-servers.sh`

```bash
#!/bin/bash
# Fetch all servers from MCP Registry API with pagination
# Classify as local (has packages) or remote (has remotes)
# Append timestamp + counts to data/snapshots.csv

set -e

ENDPOINT="https://registry.modelcontextprotocol.io/v0/servers"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:00:00Z")
LOCAL_COUNT=0
REMOTE_COUNT=0
TOTAL_COUNT=0
CURSOR=""

echo "Starting MCP server aggregation at $TIMESTAMP"

# Create data directory if it doesn't exist
mkdir -p data

while true; do
    # Fetch page
    if [ -z "$CURSOR" ]; then
        RESPONSE=$(curl -s "$ENDPOINT")
    else
        RESPONSE=$(curl -s "${ENDPOINT}?cursor=${CURSOR}")
    fi

    # Count servers on this page using jq
    PAGE_LOCAL=$(echo "$RESPONSE" | jq '[.servers[] | select(.server.packages != null)] | length')
    PAGE_REMOTE=$(echo "$RESPONSE" | jq '[.servers[] | select(.server.remotes != null)] | length')
    PAGE_TOTAL=$(echo "$RESPONSE" | jq '.servers | length')

    LOCAL_COUNT=$((LOCAL_COUNT + PAGE_LOCAL))
    REMOTE_COUNT=$((REMOTE_COUNT + PAGE_REMOTE))
    TOTAL_COUNT=$((TOTAL_COUNT + PAGE_TOTAL))

    echo "  Page processed: $PAGE_TOTAL servers ($PAGE_LOCAL local, $PAGE_REMOTE remote)"

    # Check for next page
    NEXT_CURSOR=$(echo "$RESPONSE" | jq -r '.metadata.nextCursor // empty')

    if [ -z "$NEXT_CURSOR" ]; then
        echo "  Reached end of pagination"
        break
    fi

    CURSOR="$NEXT_CURSOR"
done

echo "Total servers: $TOTAL_COUNT ($LOCAL_COUNT local, $REMOTE_COUNT remote)"

# Create CSV with header if it doesn't exist
if [ ! -f "data/snapshots.csv" ]; then
    echo "timestamp,total,local,remote" > data/snapshots.csv
    echo "Created new snapshots.csv with header"
fi

# Append new row
echo "$TIMESTAMP,$TOTAL_COUNT,$LOCAL_COUNT,$REMOTE_COUNT" >> data/snapshots.csv
echo "Appended snapshot to data/snapshots.csv"
```

**Make executable and test locally**:
```bash
chmod +x scripts/aggregate-servers.sh
bash scripts/aggregate-servers.sh
cat data/snapshots.csv
```

---

## 5. Set Up GitHub Actions

### Create `.github/workflows/aggregate-data.yml`

```yaml
name: Aggregate MCP Server Data

on:
  schedule:
    - cron: '0 * * * *'  # Every hour on the hour
  workflow_dispatch:      # Allow manual trigger

jobs:
  aggregate:
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run aggregation script
        run: bash scripts/aggregate-servers.sh

      - name: Commit and push updated data
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data/snapshots.csv
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update server snapshots [$(date -u +'%Y-%m-%d %H:%M')]"
            git push
          fi
```

**Test the workflow**:
1. Push to GitHub
2. Go to Actions tab
3. Click "Aggregate MCP Server Data"
4. Click "Run workflow" (manual trigger)
5. Verify `data/snapshots.csv` is created and committed

---

## 6. Implement Data Loading

### Create `lib/types.ts`

```typescript
export interface Snapshot {
  timestamp: string;
  total: number;
  local: number;
  remote: number;
}

export interface TimeSeries {
  snapshots: Snapshot[];
  startDate: string;
  endDate: string;
  totalSnapshots: number;
}

export type ServerType = 'all' | 'local' | 'remote';
export type Granularity = 'hourly' | 'daily' | 'weekly' | 'monthly';

export interface ChartDataPoint {
  date: string;
  timestamp: number;
  count: number;
  label?: string;
}

export interface FilterState {
  serverType: ServerType;
  granularity: Granularity;
}
```

### Create `lib/data-loader.ts`

```typescript
import fs from 'fs';
import path from 'path';
import { Snapshot, TimeSeries } from './types';

export function loadSnapshots(): TimeSeries {
  const csvPath = path.join(process.cwd(), 'data', 'snapshots.csv');

  // Handle missing file
  if (!fs.existsSync(csvPath)) {
    console.warn('snapshots.csv not found, returning empty data');
    return {
      snapshots: [],
      startDate: '',
      endDate: '',
      totalSnapshots: 0
    };
  }

  const content = fs.readFileSync(csvPath, 'utf-8');
  const snapshots = parseCSV(content);

  if (snapshots.length === 0) {
    return {
      snapshots: [],
      startDate: '',
      endDate: '',
      totalSnapshots: 0
    };
  }

  return {
    snapshots,
    startDate: snapshots[0].timestamp,
    endDate: snapshots[snapshots.length - 1].timestamp,
    totalSnapshots: snapshots.length
  };
}

function parseCSV(content: string): Snapshot[] {
  const lines = content.trim().split('\n');
  if (lines.length < 2) return [];  // Header + at least 1 data row

  const header = lines[0].split(',');
  const snapshots: Snapshot[] = [];

  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',');

    const timestamp = values[0];
    const total = parseInt(values[1], 10);
    const local = parseInt(values[2], 10);
    const remote = parseInt(values[3], 10);

    // Validate
    if (!timestamp || isNaN(total) || isNaN(local) || isNaN(remote)) {
      console.warn(`Skipping invalid row ${i}: ${lines[i]}`);
      continue;
    }

    snapshots.push({ timestamp, total, local, remote });
  }

  // Sort by timestamp
  snapshots.sort((a, b) => a.timestamp.localeCompare(b.timestamp));

  return snapshots;
}
```

### Create `lib/data-aggregator.ts`

```typescript
import { Snapshot, Granularity, ServerType, ChartDataPoint } from './types';

export function aggregateByGranularity(
  snapshots: Snapshot[],
  granularity: Granularity
): Snapshot[] {
  if (granularity === 'hourly') {
    return snapshots;
  }

  const groups: Record<string, Snapshot> = {};

  for (const snap of snapshots) {
    const key = getGranularityKey(snap.timestamp, granularity);

    // Keep latest snapshot per bucket
    if (!groups[key] || snap.timestamp > groups[key].timestamp) {
      groups[key] = snap;
    }
  }

  return Object.values(groups);
}

function getGranularityKey(timestamp: string, granularity: Granularity): string {
  const date = new Date(timestamp);

  switch (granularity) {
    case 'daily':
      return date.toISOString().split('T')[0];  // YYYY-MM-DD
    case 'weekly':
      const year = date.getUTCFullYear();
      const week = getISOWeek(date);
      return `${year}-W${week.toString().padStart(2, '0')}`;
    case 'monthly':
      return `${date.getUTCFullYear()}-${(date.getUTCMonth() + 1).toString().padStart(2, '0')}`;
    default:
      return timestamp;
  }
}

function getISOWeek(date: Date): number {
  const d = new Date(date);
  d.setUTCHours(0, 0, 0, 0);
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
}

export function toChartData(
  snapshots: Snapshot[],
  serverType: ServerType,
  granularity: Granularity
): ChartDataPoint[] {
  return snapshots.map(snap => {
    const count = serverType === 'all' ? snap.total :
                  serverType === 'local' ? snap.local :
                  snap.remote;

    const date = formatDate(snap.timestamp, granularity);
    const label = `${count} ${serverType === 'all' ? '' : serverType + ' '}servers on ${date}`;

    return {
      date,
      timestamp: new Date(snap.timestamp).getTime(),
      count,
      label
    };
  });
}

function formatDate(timestamp: string, granularity: Granularity): string {
  const date = new Date(timestamp);
  const options: Intl.DateTimeFormatOptions = { timeZone: 'UTC' };

  switch (granularity) {
    case 'hourly':
      return date.toLocaleString('en-US', { ...options, month: 'short', day: 'numeric', hour: 'numeric' });
    case 'daily':
      return date.toLocaleString('en-US', { ...options, month: 'short', day: 'numeric' });
    case 'weekly':
      return `Week ${getISOWeek(date)}, ${date.getUTCFullYear()}`;
    case 'monthly':
      return date.toLocaleString('en-US', { ...options, month: 'short', year: 'numeric' });
  }
}
```

---

## 7. Build Components

### Create navigation: `components/navigation/nav.tsx`

```tsx
import Link from 'next/link';

export function Nav() {
  return (
    <nav className="border-b border-gray-800 bg-gray-900/50 backdrop-blur">
      <div className="container mx-auto px-4 py-4 flex justify-between items-center">
        <h1 className="text-xl font-bold text-primary">MCP Analytics</h1>
        <div className="flex gap-6">
          <Link href="/" className="hover:text-primary transition">
            Dashboard
          </Link>
          <Link href="/about" className="hover:text-primary transition">
            About
          </Link>
        </div>
      </div>
    </nav>
  );
}
```

### Create filters: `components/filters/server-type-filter.tsx`

```tsx
'use client';

import { ServerType } from '@/lib/types';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

interface Props {
  value: ServerType;
  onChange: (value: ServerType) => void;
}

export function ServerTypeFilter({ value, onChange }: Props) {
  return (
    <Select value={value} onValueChange={onChange}>
      <SelectTrigger className="w-[180px]">
        <SelectValue />
      </SelectTrigger>
      <SelectContent>
        <SelectItem value="all">All Servers</SelectItem>
        <SelectItem value="local">Local Servers</SelectItem>
        <SelectItem value="remote">Remote Servers</SelectItem>
      </SelectContent>
    </Select>
  );
}
```

### Create granularity selector: `components/filters/granularity-selector.tsx`

```tsx
'use client';

import { Granularity } from '@/lib/types';
import { Button } from '@/components/ui/button';

interface Props {
  value: Granularity;
  onChange: (value: Granularity) => void;
}

const options: { label: string; value: Granularity }[] = [
  { label: 'Hourly', value: 'hourly' },
  { label: 'Daily', value: 'daily' },
  { label: 'Weekly', value: 'weekly' },
  { label: 'Monthly', value: 'monthly' }
];

export function GranularitySelector({ value, onChange }: Props) {
  return (
    <div className="flex gap-2">
      {options.map(opt => (
        <Button
          key={opt.value}
          variant={value === opt.value ? 'default' : 'outline'}
          onClick={() => onChange(opt.value)}
          className={value === opt.value ? 'bg-primary' : ''}
        >
          {opt.label}
        </Button>
      ))}
    </div>
  );
}
```

### Create chart: `components/charts/time-series-chart.tsx`

```tsx
'use client';

import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { ChartDataPoint } from '@/lib/types';
import { Card } from '@/components/ui/card';

interface Props {
  data: ChartDataPoint[];
  title?: string;
}

export function TimeSeriesChart({ data, title }: Props) {
  if (data.length === 0) {
    return (
      <Card className="p-8 text-center text-gray-500">
        No data available
      </Card>
    );
  }

  return (
    <Card className="p-6">
      {title && <h3 className="text-lg font-semibold mb-4">{title}</h3>}
      <ResponsiveContainer width="100%" height={400}>
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
          <XAxis dataKey="date" stroke="#9ca3af" />
          <YAxis stroke="#9ca3af" />
          <Tooltip
            contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151' }}
            labelStyle={{ color: '#f3f4f6' }}
          />
          <Line type="monotone" dataKey="count" stroke="#a855f7" strokeWidth={2} dot={false} />
        </LineChart>
      </ResponsiveContainer>
    </Card>
  );
}
```

---

## 8. Create Pages

### Update root layout: `app/layout.tsx`

```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { Nav } from '@/components/navigation/nav';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'MCP Server Analytics Dashboard',
  description: 'Track MCP server ecosystem growth and adoption trends'
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className="dark">
      <body className={inter.className}>
        <Nav />
        <main className="container mx-auto px-4 py-8">
          {children}
        </main>
      </body>
    </html>
  );
}
```

### Create dashboard page: `app/page.tsx`

```tsx
'use client';

import { useState } from 'react';
import { ServerType, Granularity } from '@/lib/types';
import { loadSnapshots } from '@/lib/data-loader';
import { aggregateByGranularity, toChartData } from '@/lib/data-aggregator';
import { ServerTypeFilter } from '@/components/filters/server-type-filter';
import { GranularitySelector } from '@/components/filters/granularity-selector';
import { TimeSeriesChart } from '@/components/charts/time-series-chart';

export default function DashboardPage() {
  const timeSeries = loadSnapshots();
  const [serverType, setServerType] = useState<ServerType>('all');
  const [granularity, setGranularity] = useState<Granularity>('hourly');

  const aggregated = aggregateByGranularity(timeSeries.snapshots, granularity);
  const chartData = toChartData(aggregated, serverType, granularity);

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-4xl font-bold mb-2">MCP Server Analytics</h1>
        <p className="text-gray-400">
          {timeSeries.totalSnapshots} snapshots from {timeSeries.startDate} to {timeSeries.endDate}
        </p>
      </div>

      <div className="flex gap-4 items-center">
        <ServerTypeFilter value={serverType} onChange={setServerType} />
        <GranularitySelector value={granularity} onChange={setGranularity} />
      </div>

      <TimeSeriesChart data={chartData} title="Server Growth Over Time" />
    </div>
  );
}
```

### Create about page: `app/about/page.tsx`

```tsx
export default function AboutPage() {
  return (
    <div className="prose prose-invert max-w-3xl mx-auto">
      <h1>About</h1>

      <p>
        The MCP Server Analytics Dashboard tracks the growth and adoption of servers
        in the Model Context Protocol ecosystem.
      </p>

      <h2>Data Source</h2>
      <p>
        Data is fetched hourly from the official MCP Registry API at{' '}
        <code>https://registry.modelcontextprotocol.io/v0/servers</code>.
      </p>

      <h2>Server Classification</h2>
      <ul>
        <li><strong>Local servers</strong>: Have a <code>packages</code> property</li>
        <li><strong>Remote servers</strong>: Have a <code>remotes</code> property</li>
        <li>Servers can be both local and remote if they have both properties</li>
      </ul>

      <h2>Update Frequency</h2>
      <p>
        Snapshots are captured every hour via GitHub Actions.
      </p>
    </div>
  );
}
```

---

## 9. Test & Build

### Development Server

```bash
npm run dev
```

Visit `http://localhost:3000`

### Build Static Site

```bash
npm run build
```

Output directory: `./out`

### Preview Static Build

```bash
npx serve out
```

---

## 10. Deploy

### Option A: Vercel

```bash
npm install -g vercel
vercel
```

### Option B: Netlify

```bash
npm install -g netlify-cli
netlify deploy --prod --dir=out
```

### Option C: GitHub Pages

1. Update `.github/workflows/aggregate-data.yml` to trigger deploy on data update
2. Add deploy job:
   ```yaml
   - name: Build Next.js
     run: npm run build

   - name: Deploy to GitHub Pages
     uses: peaceiris/actions-gh-pages@v3
     with:
       github_token: ${{ secrets.GITHUB_TOKEN }}
       publish_dir: ./out
   ```

---

## Next Steps

1. ✅ Test hourly GitHub Actions runs
2. ✅ Verify CSV accumulates data correctly
3. ✅ Test responsive design on mobile
4. ✅ Run Lighthouse audit for performance
5. ✅ Check WCAG AA color contrast
6. ✅ Add error boundaries for production

## Troubleshooting

**Problem**: GitHub Actions fails with "permission denied"
**Solution**: Ensure workflow has write permissions in repository settings

**Problem**: Charts don't render
**Solution**: Check browser console for data format errors, validate CSV structure

**Problem**: Build fails with "Module not found"
**Solution**: Run `npm install` and verify all dependencies are installed
