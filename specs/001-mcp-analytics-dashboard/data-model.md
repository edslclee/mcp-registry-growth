# Data Model: MCP Server Analytics Dashboard

**Created**: 2025-10-28
**Purpose**: Define data structures and relationships for server analytics

## Overview

This application works with **immutable snapshot data** - there are no mutations, only reads and client-side aggregations. Data flows:

1. **Source**: MCP Registry API → GitHub Actions
2. **Storage**: `data/snapshots.csv` (time-series)
3. **Processing**: Next.js build-time read → client-side aggregation
4. **Display**: React components with filtering/granularity controls

---

## Entities

### 1. Snapshot

Represents a point-in-time count of MCP servers, captured hourly by GitHub Actions.

**Fields**:
- `timestamp`: ISO 8601 datetime string (UTC, rounded to hour), e.g., `"2025-10-28T14:00:00Z"`
- `total`: Number - total count of unique servers in registry
- `local`: Number - count of servers with `server.packages` property (packages != null)
- `remote`: Number - count of servers with `server.remotes` property (remotes != null)

**Validation Rules**:
- `timestamp` MUST be valid ISO 8601 format
- `total`, `local`, `remote` MUST be non-negative integers
- `local + remote >= total` (servers can have both properties)
- **Derived value**: `both = (local + remote) - total` (servers counted in both categories)

**Classification Logic** (verified 2025-10-29):
- Servers can belong to multiple categories simultaneously
- Example distribution from 1,427 servers:
  - Local only: 817 (57.2%)
  - Remote only: 513 (35.9%)
  - Both: 48 (3.4%) - have both `packages` and `remotes`
  - Neither: 49 (3.4%) - metadata-only entries

**Source**: Generated by `scripts/aggregate-servers.sh` and appended to `data/snapshots.csv`

**Example** (actual data from 2025-10-29):
```typescript
{
  timestamp: "2025-10-29T02:00:00Z",
  total: 1427,
  local: 865,
  remote: 561
}
// Note: 865 + 561 = 1426 < 1427 due to 49 servers with neither property
// Servers with both: If we had all servers categorized: both = 48
```

**CSV Format**:
```csv
timestamp,total,local,remote
2025-10-29T01:00:00Z,1427,865,561
2025-10-29T02:00:00Z,1427,865,561
```

---

### 2. Time Series

Collection of snapshots representing server growth over time.

**Structure**:
```typescript
interface TimeSeries {
  snapshots: Snapshot[];
  startDate: string;  // ISO 8601 of first snapshot
  endDate: string;    // ISO 8601 of last snapshot
  totalSnapshots: number;
}
```

**Operations**:
- **Load**: Read from CSV at build time
- **Filter**: Apply server type filter (all/local/remote)
- **Aggregate**: Re-bucket by granularity (hourly/daily/weekly/monthly)

**Aggregation Logic** (for granularity changes):
- **Hourly**: No aggregation, use raw snapshots
- **Daily**: Group by date (YYYY-MM-DD), use **latest snapshot** of each day
- **Weekly**: Group by ISO week (YYYY-Www), use **latest snapshot** of each week
- **Monthly**: Group by month (YYYY-MM), use **latest snapshot** of each month

**Rationale for "latest snapshot"**:
- Spec states: "counts are latest snapshots, we can always rely on the latest value"
- Servers don't decrease (monotonic growth), so latest value is most accurate

---

### 3. Filter State

Represents user's current view preferences.

**Fields**:
```typescript
interface FilterState {
  serverType: 'all' | 'local' | 'remote';
  granularity: 'hourly' | 'daily' | 'weekly' | 'monthly';
}
```

**Default Values**:
- `serverType`: `'all'` (show combined metrics)
- `granularity`: `'hourly'` (per spec requirement FR-007)

**State Management**: React `useState` hooks (no global state needed, single page)

---

### 4. Chart Data Point

Derived structure optimized for Recharts rendering.

**Structure**:
```typescript
interface ChartDataPoint {
  date: string;       // Formatted for X-axis label (e.g., "Oct 28, 14:00" or "Oct 28")
  timestamp: number;  // Unix timestamp for sorting/comparison
  count: number;      // Server count for Y-axis
  label?: string;     // Optional tooltip label
}
```

**Transformation Flow**:
```
Snapshot[] → Filter by serverType → Aggregate by granularity → ChartDataPoint[]
```

**Example Transformation** (Daily granularity, Local servers):
```typescript
// Input: Hourly snapshots for Oct 28
[
  { timestamp: "2025-10-28T10:00:00Z", total: 450, local: 320, remote: 150 },
  { timestamp: "2025-10-28T14:00:00Z", total: 452, local: 321, remote: 151 },
  { timestamp: "2025-10-28T20:00:00Z", total: 455, local: 323, remote: 152 }
]

// Output: Single daily data point (latest snapshot)
[
  { date: "Oct 28", timestamp: 1698523200000, count: 323, label: "Local servers on Oct 28" }
]
```

---

## MCP Registry API Structure

### API Endpoint

**URL**: `https://registry.modelcontextprotocol.io/v0/servers`

### Response Format

```typescript
interface APIResponse {
  servers: ServerEntry[];
  metadata: {
    nextCursor?: string;  // Present if more pages available
  };
}

interface ServerEntry {
  server: {
    $schema: string;
    name: string;        // e.g., "ai.aliengiraffe/spotdb"
    description: string;
    repository: {
      url: string;
      source: string;
    };
    version: string;
    packages?: Package[];  // If null/undefined → not a local server
    remotes?: Remote[];    // If null/undefined → not a remote server
  };
  _meta: {
    "io.modelcontextprotocol.registry/official": {
      status: string;
      publishedAt: string;
      updatedAt: string;
      isLatest: boolean;
    };
  };
}

interface Package {
  registryType: string;  // e.g., "oci", "npm"
  identifier: string;
  transport: {
    type: string;
  };
  environmentVariables?: Array<{
    name: string;
    description: string;
    format: string;
    isSecret: boolean;
  }>;
}

interface Remote {
  type: string;  // e.g., "streamable-http", "sse"
  url: string;
}
```

### Pagination

- **Method**: Cursor-based pagination
- **Cursor Location**: `response.metadata.nextCursor`
- **Usage**: Append `?cursor={nextCursor}` to endpoint URL
- **Page Size**: 30 servers per page (API-determined)
- **Total Pages**: ~48 pages as of 2025-10-29 (1,427 servers)

### Classification Algorithm

```bash
# From scripts/aggregate-servers.sh

for each page:
  LOCAL += count(servers where .server.packages != null)
  REMOTE += count(servers where .server.remotes != null)
  TOTAL += count(servers)

  if .metadata.nextCursor exists:
    fetch next page with cursor
  else:
    break
```

### Verified Example Servers

**Local only** (has packages, no remotes):
```json
{
  "server": {
    "name": "ai.aliengiraffe/spotdb",
    "packages": [
      {
        "registryType": "oci",
        "identifier": "docker.io/aliengiraffe/spotdb:0.1.0"
      }
    ]
    // remotes: not present
  }
}
```

**Remote only** (has remotes, no packages):
```json
{
  "server": {
    "name": "ai.alpic.test/test-mcp-server",
    "remotes": [
      {
        "type": "streamable-http",
        "url": "https://test.alpic.ai/"
      }
    ]
    // packages: not present
  }
}
```

**Both** (has packages AND remotes):
```json
{
  "server": {
    "name": "ai.shawndurrani/mcp-merchant",
    "packages": [...],
    "remotes": [...]
  }
}
```

---

## Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│ MCP Registry API                                                 │
│ https://registry.modelcontextprotocol.io/v0/servers             │
│ https://...?cursor={nextCursor}                                 │
└────────────────────────┬────────────────────────────────────────┘
                         │ Cursor pagination (.metadata.nextCursor)
                         │ ~48 pages × 30 servers/page
                         ↓
┌─────────────────────────────────────────────────────────────────┐
│ GitHub Actions (hourly on macOS)                                │
│ scripts/aggregate-servers.sh (bash + curl + jq)                 │
│ - Fetch all servers with cursor pagination                       │
│ - Classify: .server.packages != null → local                    │
│            .server.remotes != null → remote                     │
│ - Count totals (servers can be both)                            │
└────────────────────────┬────────────────────────────────────────┘
                         │ Append CSV row
                         ↓
┌─────────────────────────────────────────────────────────────────┐
│ data/snapshots.csv (version controlled)                          │
│ timestamp,total,local,remote                                     │
│ 2025-10-29T01:00:00Z,1427,865,561                               │
│ 2025-10-29T02:00:00Z,1427,865,561                               │
│ ...                                                              │
└────────────────────────┬────────────────────────────────────────┘
                         │ Build time
                         ↓
┌─────────────────────────────────────────────────────────────────┐
│ Next.js Build (lib/data-loader.ts)                               │
│ - Read CSV file                                                  │
│ - Parse to Snapshot[]                                            │
│ - Bundle into static page                                        │
└────────────────────────┬────────────────────────────────────────┘
                         │ Embedded in JS
                         ↓
┌─────────────────────────────────────────────────────────────────┐
│ Browser Runtime                                                  │
│                                                                  │
│ ┌──────────────┐   Filter State   ┌──────────────────────────┐ │
│ │ User Actions │  ───────────────→ │ lib/data-aggregator.ts   │ │
│ │ - Change     │                   │ - Filter by serverType   │ │
│ │   serverType │                   │ - Aggregate by           │ │
│ │ - Change     │                   │   granularity            │ │
│ │   granularity│                   │ - Transform to Chart     │ │
│ └──────────────┘                   │   Data Points            │ │
│                                     └──────────┬───────────────┘ │
│                                                │                 │
│                                                ↓                 │
│                                     ┌──────────────────────────┐ │
│                                     │ Recharts Component       │ │
│                                     │ - Render LineChart       │ │
│                                     │ - X-axis: date           │ │
│                                     │ - Y-axis: count          │ │
│                                     └──────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

---

## Type Definitions (TypeScript)

**File**: `lib/types.ts`

```typescript
// === Core Data Types ===

export interface Snapshot {
  timestamp: string;  // ISO 8601
  total: number;
  local: number;
  remote: number;
}

export interface TimeSeries {
  snapshots: Snapshot[];
  startDate: string;
  endDate: string;
  totalSnapshots: number;
}

// === Filter State ===

export type ServerType = 'all' | 'local' | 'remote';
export type Granularity = 'hourly' | 'daily' | 'weekly' | 'monthly';

export interface FilterState {
  serverType: ServerType;
  granularity: Granularity;
}

// === Chart Data ===

export interface ChartDataPoint {
  date: string;
  timestamp: number;
  count: number;
  label?: string;
}

// === CSV Parsing ===

export interface CSVRow {
  timestamp: string;
  total: string;
  local: string;
  remote: string;
}
```

---

## Data Validation

### On CSV Parse (Build Time)

**File**: `lib/data-loader.ts`

```typescript
function validateSnapshot(row: CSVRow): Snapshot | null {
  // Validate timestamp format
  const date = new Date(row.timestamp);
  if (isNaN(date.getTime())) {
    console.warn(`Invalid timestamp: ${row.timestamp}`);
    return null;
  }

  // Validate numeric fields
  const total = parseInt(row.total, 10);
  const local = parseInt(row.local, 10);
  const remote = parseInt(row.remote, 10);

  if (isNaN(total) || isNaN(local) || isNaN(remote)) {
    console.warn(`Invalid counts in row: ${JSON.stringify(row)}`);
    return null;
  }

  if (total < 0 || local < 0 || remote < 0) {
    console.warn(`Negative counts in row: ${JSON.stringify(row)}`);
    return null;
  }

  return { timestamp: row.timestamp, total, local, remote };
}
```

**Error Handling**: Skip invalid rows, log warnings during build, continue with valid data

---

## Aggregation Examples

### Daily Granularity

**Input** (3 hourly snapshots on Oct 28):
```typescript
[
  { timestamp: "2025-10-28T10:00:00Z", total: 450, local: 320, remote: 150 },
  { timestamp: "2025-10-28T14:00:00Z", total: 452, local: 321, remote: 151 },
  { timestamp: "2025-10-28T20:00:00Z", total: 455, local: 323, remote: 152 }
]
```

**Output** (1 daily data point):
```typescript
[
  {
    date: "Oct 28",
    timestamp: 1730150400000,  // 2025-10-28T20:00:00Z (latest)
    count: 455,  // total count from latest snapshot
    label: "455 servers on Oct 28"
  }
]
```

### Filter: Local Servers Only

**Input** (same 3 snapshots):
```typescript
// Before filter
snapshots[0].total = 450
snapshots[0].local = 320

// After applying serverType='local'
// Use .local field instead of .total
count = 320  (not 450)
```

---

## Storage Considerations

### CSV File Growth

- **Frequency**: 1 row per hour
- **Row Size**: ~50 bytes (timestamp + 3 integers)
- **Growth Rate**: 50 bytes × 24 hours × 365 days = **~450 KB/year**
- **10-Year Projection**: ~4.5 MB

**Conclusion**: CSV file size is negligible, no archival/cleanup needed

### Build-Time Performance

- **1000 snapshots** (~42 days of data)
- **Parse time**: <10ms (native JavaScript split/map)
- **Bundle size**: 1000 rows × 50 bytes = **~50 KB** embedded in JS

**Constitution Compliance**: Well within performance and bundle size budgets

---

## Summary

- **3 core entities**: Snapshot, Time Series, Filter State
- **1 derived entity**: Chart Data Point
- **Data flow**: API → GitHub Actions → CSV → Next.js build → Browser
- **No mutations**: Read-only data, client-side transformations only
- **Validation**: Build-time checks with graceful error handling
- **Scalability**: CSV format efficient for multi-year retention

All entity definitions align with spec requirements and constitution principles.
